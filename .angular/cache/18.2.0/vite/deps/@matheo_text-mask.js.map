{
  "version": 3,
  "sources": ["../../../../../node_modules/@matheo/text-mask/fesm2022/matheo-text-mask.mjs"],
  "sourcesContent": ["import * as i0 from '@angular/core';\nimport { forwardRef, Directive, Optional, Inject, Input, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';\nimport { ÉµgetDOM as _getDOM } from '@angular/platform-browser';\nclass TextMaskConfig {}\nconst defaultPlaceholderChar = '_';\nconst err$1 = 'text-mask: convertMaskToPlaceholder; The mask property must be an array.';\nfunction convertMaskToPlaceholder(mask, placeholderChar = defaultPlaceholderChar) {\n  if (!isArray(mask)) {\n    throw new Error(err$1);\n  }\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error('Placeholder character must not be used as part of the mask. Please specify a character ' + 'that is not present in your mask as your placeholder character.\\n\\n' + `The placeholder character that was received is: ${JSON.stringify(placeholderChar)}\\n\\n` + `The mask that was received is: ${JSON.stringify(mask)}`);\n  }\n  return mask.map(char => {\n    return char instanceof RegExp ? placeholderChar : char;\n  }).join('');\n}\nfunction isMaskCreator(value) {\n  return typeof value === 'function';\n}\nfunction isMaskObject(value) {\n  return typeof value === 'object' && value.pipe !== undefined && value.mask !== undefined;\n}\nfunction isArray(value) {\n  return Array.isArray && Array.isArray(value) || value instanceof Array;\n}\nfunction isString(value) {\n  return typeof value === 'string' || value instanceof String;\n}\nfunction isNumber(value) {\n  return typeof value === 'number' && !isNaN(value);\n}\nfunction isNil(value) {\n  return typeof value === 'undefined' || value === null;\n}\nfunction processCaretTraps(mask) {\n  const caretTrapIndexes = [];\n  let indexOfCaretTrap = mask?.indexOf('[]');\n  while (mask && indexOfCaretTrap !== -1) {\n    caretTrapIndexes.push(indexOfCaretTrap);\n    mask.splice(indexOfCaretTrap, 1);\n    indexOfCaretTrap = mask.indexOf('[]');\n  }\n  return caretTrapIndexes;\n}\nconst err = 'Text-mask:conformToMask; The mask property must be an array.';\nfunction conformToMask(rawValue = '', mask = [], config = {}) {\n  if (!isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (isMaskCreator(mask)) {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config);\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      processCaretTraps(mask);\n    } else {\n      throw new Error(err);\n    }\n  }\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = '',\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions\n  } = config;\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined;\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const maskLength = mask.length;\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength;\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0;\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange = (currentCaretPosition || 0) + (isAddition ? -editDistance : 0);\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = '';\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    }\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue = rawValue.slice(0, indexOfFirstChange) + compensatingPlaceholderChars + rawValue.slice(indexOfFirstChange, rawValueLength);\n  }\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue.split('').map((char, i) => ({\n    char,\n    isNew: i >= indexOfFirstChange && i < indexOfLastChange\n  }));\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const {\n      char\n    } = rawValueArr[i];\n    if (char !== placeholderChar) {\n      const shouldOffset = i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  }\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = '';\n  let someCharsRejected = false;\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i];\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const res = rawValueArr.shift();\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (res?.char === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar;\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (res?.char && mask[i].test(res.char)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (keepCharPositions !== true || res?.isNew === false || previousConformedValue === '' || guide === false || !isAddition) {\n              conformedValue += res?.char;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length;\n              let indexOfNextAvailablePlaceholderChar = null;\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let k = 0; k < rawValueArrLength; k++) {\n                const charData = rawValueArr[k];\n                if (charData.char !== placeholderChar && charData.isNew === false) {\n                  break;\n                }\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = k;\n                  break;\n                }\n              }\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += res?.char;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                i--;\n              }\n            }\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength);\n      }\n      // And we break\n      break;\n      // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null;\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i;\n      }\n    }\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(0, indexOfLastFilledPlaceholderChar + 1);\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = '';\n    }\n  }\n  return {\n    conformedValue,\n    meta: {\n      someCharsRejected\n    }\n  };\n}\nfunction adjustCaretPosition({\n  previousConformedValue = '',\n  previousPlaceholder = '',\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = [],\n  caretTrapIndexes = []\n}) {\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  }\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const conformedValueLength = conformedValue.length;\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength;\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0;\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0;\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit = editLength > 1 && !isAddition && !isFirstRawValue;\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  }\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar = isAddition && (previousConformedValue === conformedValue || conformedValue === placeholder);\n  let startingSearchIndex = 0;\n  let trackRightCharacter;\n  let targetChar = '';\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase();\n    const normalizedRawValue = rawValue.toLowerCase();\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue.substr(0, currentCaretPosition).split('');\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter(char => normalizedConformedValue.indexOf(char) !== -1);\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1];\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder.substr(0, intersection.length).split('').filter(char => char !== placeholderChar).length;\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder.substr(0, intersection.length).split('').filter(char => char !== placeholderChar).length;\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft = previousPlaceholder[intersection.length - 1] !== undefined && placeholder[intersection.length - 2] !== undefined && previousPlaceholder[intersection.length - 1] !== placeholderChar && previousPlaceholder[intersection.length - 1] !== placeholder[intersection.length - 1] && previousPlaceholder[intersection.length - 1] === placeholder[intersection.length - 2];\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (!isAddition && (masklengthChanged || targetIsMaskMovingLeft) && previousLeftMaskChars > 0 && placeholder.indexOf(targetChar) > -1 && rawValue[currentCaretPosition] !== undefined) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    }\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map(index => normalizedConformedValue[index]);\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter(char => char === targetChar).length;\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter(char => char === targetChar).length;\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder.substr(0, placeholder.indexOf(placeholderChar)).split('').filter((char, index) =>\n    // Check if `char` is the same as our `targetChar`, so we account for it\n    char === targetChar &&\n    // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n    // index because if they are equal, that means we are already counting those characters in\n    // `countTargetCharInIntersection`\n    rawValue[index] !== char).length;\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches = countTargetCharInPlaceholder + countTargetCharInIntersection + countTargetCharInPipedChars + (\n    // The character to the right of the caret isn't included in `intersection`\n    // so add one if we are tracking the character to the right\n    trackRightCharacter ? 1 : 0);\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0;\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i];\n      startingSearchIndex = i + 1;\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  }\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex;\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i;\n      }\n      if (\n      // If we're adding, we can position the caret at the next placeholder character.\n      placeholder[i] === placeholderChar ||\n      // If a caret trap was set by a mask function, we need to stop at the trap.\n      caretTrapIndexes.indexOf(i) !== -1 ||\n      // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n      i === placeholderLength) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n        if (\n        // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n        // to the right of the caret\n        conformedValue[i] === targetChar ||\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n        // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        i === 0) {\n          return i;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n        if (\n        // If we're deleting, we can position the caret right before the placeholder character\n        placeholder[i - 1] === placeholderChar ||\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n        // This is the beginning of the placeholder. We cannot move any further.\n        // Let's put the caret there.\n        i === 0) {\n          return i;\n        }\n      }\n    }\n  }\n}\nconst isAndroid = typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nconst defer = typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame : setTimeout;\nfunction createTextMaskInputElement(config) {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  const state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined\n  };\n  return {\n    state,\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update(rawValue, {\n      inputElement,\n      mask: providedMask,\n      guide,\n      pipe,\n      placeholderChar = defaultPlaceholderChar,\n      keepCharPositions = false,\n      showMask = false\n    } = config) {\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      }\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) {\n        return;\n      }\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      let mask;\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we destructure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (isMaskObject(providedMask)) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      }\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      let placeholder = '';\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      }\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (!providedMask) {\n        return;\n      }\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      const safeRawValue = getSafeRawValue(rawValue);\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      const {\n        selectionEnd: currentCaretPosition\n      } = inputElement;\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      const {\n        previousConformedValue,\n        previousPlaceholder\n      } = state;\n      let caretTrapIndexes = [];\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition,\n          previousConformedValue,\n          placeholderChar\n        });\n        // disable masking if `mask` is `false`\n        if (!mask) {\n          return;\n        }\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        caretTrapIndexes = processCaretTraps(mask);\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n      } else {\n        // if the `providedMask` is not a function, we just use it as-is.\n        mask = providedMask;\n      }\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      const conformToMaskConfig = {\n        previousConformedValue,\n        guide,\n        placeholder,\n        placeholderChar,\n        pipe,\n        currentCaretPosition,\n        keepCharPositions\n      };\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      const {\n        conformedValue\n      } = conformToMask(safeRawValue, mask, conformToMaskConfig);\n      // The following few lines are to support the `pipe` feature.\n      let pipeResults = {};\n      // we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      let finalConformedValue = conformedValue;\n      // If `pipe` is a function, we call it.\n      if (typeof pipe === 'function') {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, {\n          rawValue: safeRawValue,\n          ...conformToMaskConfig\n        });\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = {\n            value: previousConformedValue,\n            rejected: true\n          };\n          finalConformedValue = previousConformedValue;\n        } else if (isString(pipeResults)) {\n          pipeResults = {\n            value: pipeResults\n          };\n          finalConformedValue = pipeResults;\n        }\n      }\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      const adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue,\n        previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition: currentCaretPosition || 0,\n        placeholderChar,\n        indexesOfPipedChars: pipeResults.indexesOfPipedChars,\n        caretTrapIndexes\n      });\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty = finalConformedValue === placeholder && (adjustedCaretPosition === 0 || adjustedCaretPosition === placeholder.length - 1);\n      const emptyValue = showMask ? placeholder : '';\n      const inputElementValue = inputValueShouldBeEmpty ? emptyValue : finalConformedValue;\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n      state.previousPlaceholder = placeholder;\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n      inputElement.value = inputElementValue; // set the input value\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    }\n  };\n}\nfunction safeSetSelection(element, selectionPosition) {\n  if (document.activeElement === element && isNumber(selectionPosition)) {\n    if (isAndroid) {\n      defer(() => element.setSelectionRange(selectionPosition, selectionPosition, 'none'));\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\nfunction getSafeRawValue(inputValue) {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return '';\n  } else {\n    throw new Error('The \\'value\\' provided to Text Mask needs to be a string or a number. The value ' + `received was:\\n\\n ${JSON.stringify(inputValue)}`);\n  }\n}\nconst MASKEDINPUT_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MaskedInputDirective),\n  multi: true\n};\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid() {\n  const userAgent = _getDOM() ? _getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\nclass MaskedInputDirective {\n  constructor(renderer, elementRef, compositionMode) {\n    this.renderer = renderer;\n    this.elementRef = elementRef;\n    this.compositionMode = compositionMode;\n    this.textMaskConfig = {\n      mask: [],\n      guide: true,\n      placeholderChar: '_',\n      pipe: undefined,\n      keepCharPositions: false\n    };\n    /** Whether the user is creating a composition string (IME events). */\n    this.composing = false;\n    this.onChange = _ => {};\n    this.onTouched = () => {};\n    if (this.compositionMode == null) {\n      this.compositionMode = !_isAndroid();\n    }\n  }\n  ngOnChanges() {\n    this._setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n  writeValue(value) {\n    this._setupMask();\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value;\n    this.renderer.setProperty(this.inputElement, 'value', normalizedValue);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  }\n  registerOnChange(fn) {\n    this.onChange = fn;\n  }\n  registerOnTouched(fn) {\n    this.onTouched = fn;\n  }\n  setDisabledState(isDisabled) {\n    this.renderer.setProperty(this.elementRef.nativeElement, 'disabled', isDisabled);\n  }\n  _handleInput(value) {\n    if (!this.compositionMode || this.compositionMode && !this.composing) {\n      this._setupMask();\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value);\n        // get the updated value\n        value = this.inputElement.value;\n        this.onChange(value);\n      }\n    }\n  }\n  _setupMask(create = false) {\n    if (!this.inputElement) {\n      if (this.elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this.elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this.elementRef.nativeElement.getElementsByTagName('INPUT')[0];\n      }\n    }\n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(Object.assign({\n        inputElement: this.inputElement\n      }, this.textMaskConfig));\n    }\n  }\n  _compositionStart() {\n    this.composing = true;\n  }\n  _compositionEnd(value) {\n    this.composing = false;\n    if (this.compositionMode) {\n      this._handleInput(value);\n    }\n  }\n  /** @nocollapse */\n  static {\n    this.Éµfac = function MaskedInputDirective_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || MaskedInputDirective)(i0.ÉµÉµdirectiveInject(i0.Renderer2), i0.ÉµÉµdirectiveInject(i0.ElementRef), i0.ÉµÉµdirectiveInject(COMPOSITION_BUFFER_MODE, 8));\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.Éµdir = /* @__PURE__ */i0.ÉµÉµdefineDirective({\n      type: MaskedInputDirective,\n      selectors: [[\"\", \"textMask\", \"\"]],\n      hostBindings: function MaskedInputDirective_HostBindings(rf, ctx) {\n        if (rf & 1) {\n          i0.ÉµÉµlistener(\"input\", function MaskedInputDirective_input_HostBindingHandler($event) {\n            return ctx._handleInput($event.target.value);\n          })(\"blur\", function MaskedInputDirective_blur_HostBindingHandler() {\n            return ctx.onTouched();\n          })(\"compositionstart\", function MaskedInputDirective_compositionstart_HostBindingHandler() {\n            return ctx._compositionStart();\n          })(\"compositionend\", function MaskedInputDirective_compositionend_HostBindingHandler($event) {\n            return ctx._compositionEnd($event.target.value);\n          });\n        }\n      },\n      inputs: {\n        textMaskConfig: [0, \"textMask\", \"textMaskConfig\"]\n      },\n      exportAs: [\"textMask\"],\n      features: [i0.ÉµÉµProvidersFeature([MASKEDINPUT_VALUE_ACCESSOR]), i0.ÉµÉµNgOnChangesFeature]\n    });\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(MaskedInputDirective, [{\n    type: Directive,\n    args: [{\n      host: {\n        '(input)': '_handleInput($event.target.value)',\n        '(blur)': 'onTouched()',\n        '(compositionstart)': '_compositionStart()',\n        '(compositionend)': '_compositionEnd($event.target.value)'\n      },\n      selector: '[textMask]',\n      exportAs: 'textMask',\n      providers: [MASKEDINPUT_VALUE_ACCESSOR]\n    }]\n  }], () => [{\n    type: i0.Renderer2\n  }, {\n    type: i0.ElementRef\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [COMPOSITION_BUFFER_MODE]\n    }]\n  }], {\n    textMaskConfig: [{\n      type: Input,\n      args: ['textMask']\n    }]\n  });\n})();\nclass TextMaskModule {\n  /** @nocollapse */static {\n    this.Éµfac = function TextMaskModule_Factory(__ngFactoryType__) {\n      return new (__ngFactoryType__ || TextMaskModule)();\n    };\n  }\n  /** @nocollapse */\n  static {\n    this.Éµmod = /* @__PURE__ */i0.ÉµÉµdefineNgModule({\n      type: TextMaskModule,\n      declarations: [MaskedInputDirective],\n      exports: [MaskedInputDirective]\n    });\n  }\n  /** @nocollapse */\n  static {\n    this.Éµinj = /* @__PURE__ */i0.ÉµÉµdefineInjector({});\n  }\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ÉµsetClassMetadata(TextMaskModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [MaskedInputDirective],\n      exports: [MaskedInputDirective]\n    }]\n  }], null, null);\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { MASKEDINPUT_VALUE_ACCESSOR, MaskedInputDirective, TextMaskModule, conformToMask };\n"],
  "mappings": "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",
  "names": []
}
